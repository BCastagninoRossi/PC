EL MODELO WATERFALL - Cascada1. Requerimientos  ---   que quiere el cliente, cual es el problema a resolver2. Analisis/Especificacion  ---  qué tiene que hacer el sistema? cuales son las entradas y salidas?3. Diseño  --  cómo lo voy a resolver? qué algoritmos voy a usar?4. Implementacion  --- Pasar el diseño a un lenguaje/framework especifico5. Testing  ---  Diseñar pruebas, probar la solución6. Mantenimiento  ---  Cambiar la solucion de acuerdo a las nuevas demandasej:1) convertir valor de imperial a internacional2) 1 milla = 1.6093 km, 1 pie = 30.48cm, etc3) leer valores, calcular, mostrar resultado4) def main() millas = int(input("Millas: ")), etc5) imperial_a_S(1,0,0) == lo que quiero?6) Mantenimiento*** Esta manera de trabajar puede llegar a funcionar en la vida real pero los problemas son tan dinámicos y cambiantes que asi como esta es poco aplicableMETODOLOG[IAS ÁGILES* Los pasos son similares a los de Waterfall pero se descompone el problema en multiples partes pequeñas que se ponen como objetivos en un lapso determinado (ej: esta va a ser la tarea esta semana)* Se divide en distintos SPRINTS* ETAPAS: Plan - design - develop - test - deploy - review - launchCALIDAD DEL SOFTWARE*Confiabilidad - que el codigo sea confiable, que lo pueda usar y que no se va a morir de la nada  ej. genere una bluescreen*Testeabilidad - test design, test fails, test passes, refactor (con lo que arregle prara que pase la test lo mergeo con mi codigo)*Performance - selfexplanatory*Usabilidad - que tan facil/dificil es de usar*Mantenibilidad - que el códgo sea de calidad, que dentro de 10 años alguien lo va a leer y lo va a entender ( que no sea spaghetti code)*Escalabilidad -  que nuestro programa pueda crecer y no morir ante la demanda de usuarios*Portabilidad - que se pueda ejecutar en distintas arquitecturas y sistemas operativos*Seguridad - puedo confiar informacion a mi programa?